#+TITLE: Divine User Manuel
:PREAMBLE:
#+AUTHOR: Thibault Polge
#+EMAIL: thibault@thb.lt
#+DATE: 2020
#+LANGUAGE: en

#+TEXINFO_DIR_CATEGORY: Emacs
#+TEXINFO_DIR_TITLE: Divine: (divine).
#+TEXINFO_DIR_DESC: Modal editing
#+SUBTITLE: For version 0.0 (pre-alpha)

#+TEXINFO_DEFFN: t
#+OPTIONS: H:4 num:3 toc:2
#+BIND: ox-texinfo+-before-export-hook ox-texinfo+-update-copyright-years
#+BIND: ox-texinfo+-before-export-hook ox-texinfo+-update-version-strings

Divine is a modal editing interface for Emacs, inspired by Vim, but
which doesn't try to emulate Vim.  Instead, it attempts to bring modal
editing that feels native to Emacs and integrate well with common
Emacs bindings.

This manual is for Divine version 0.0 (pre-alpha)

#+BEGIN_QUOTE
Copyright (C) 2020 Thibault Polge <thibault@thb.lt>

You can redistribute this document and/or modify it under the terms
of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any
later version.

This document is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.
#+END_QUOTE
:END:

#+NAME: describe
#+begin_src emacs-lisp :var func='nil var='nil :exports none :results value raw hsilent
  (let ((type (cond ((and func (macrop func)) "Macro")
                    (func "Function")
                    (var "Variable")
                    (t (error "Cannot describe %s as a function or %s as a variable." func var))))
          (doc (documentation func t)) )
      (with-temp-buffer
        (insert (format " - %s: *%s*\n\n" type (symbol-name func)))
        (if func (insert (documentation func nil)) (documentation-property var 'variable-documentation nil))
        (when func
          (goto-char (point-max))
          (delete-char -1)
          (beginning-of-line)
          (delete-char 4)
          (kill-line)
          (goto-char (point-min))
          (end-of-line)
          (insert " /")
          (yank)
          (insert "/")
          ;; Indent
          (while (not (eobp))
            (next-logical-line)
            (beginning-of-line)
            (insert "    "))
        (buffer-string))))
#+end_src

#+CALL: describe(func='divine-defmode)

#+CALL: describe(func='divine-define-key)



* Introduction

Divine is a modal editing interface for Emacs, inspired by Vim, but
which doesn't try to emulate Vim.  Instead, it attempts to bring modal
editing that feels native to Emacs and integrate well with common
Emacs bindings.

* Installation

** Manual installation

Clone the source repository somewhere in your =load-path=, and convert
this manual to texinfo by running:

#+begin_src shell
  makeinfo --no-split divine.texi -o divine.info
  install-info divine.info --dir=dir
#+end_src

** TODO Install from Melpa

** TODO Install from Git, with Borg

** TODO Install from Git, with Straight

* Basic usage

This chapter

* Fundamental concepts
:PROPERTIES:
:custom_id: fundamental-concepts
:END:

This section describes the fundamental concepts of Divine.

People who wish to use Divine as a framework should read this section
closely.  Although most examples assume that the standard Divine
interface, its presentation is general enough.

** Modes

Divine is a modal interface.  A modal interface is an interface in
which the results of an action is determined by the current mode.
Although Divine provides a complete set modes, this chapter will only
focus on the two most essential: *Normal* and *Insert*.

 - *Insert mode* ::  is similar to regular Emacs, except it has a
   binding to switch to Normal mode.

*Normal mode* binds single letters to composable action and motion
commands.  It is also the entry point to other modes.

Modes in Divine can be activated permanently or temporarily.
Temporary activation is called *transient*.  A transient mode will
terminate and revert to the previous mode as soon as an action has
completed.

Being transient isn't a property of the mode, but of the activation of
a mode.

** Commands

A *command* is nothing more than a regular Emacs command, that is, an
~(interactive)~ function.  Commands can be bound in Divine the same
way they're bound in regular Emacs.  Because Divine underlying
interface is a bit more tricky than Emacs',

** Operators

An *operator* is a command that operates on a region.  Actions are
normally bound to Normal mode.  If an action is invoked with an
existing, non empty region, it is run immediately on this region.

Otherwise, the normal mode switches to the “pending object” state.  In
this state, the next motion action creates a region, and the command
is run on this region.  For example, the sequence:

#+begin_example
  d5F
#+end_example

will delete the five next words.

 - =d= is the default binding to the kill command.  If d is run on a
   region, the region is immediately deleted and copied to kill ring.
 - =5= is a regular prefix argument
 - =F= is the default binding for the forward word command.

** Motion and text objects

*Motions* are commands that move the point around.  If they're entered
without a pending operator, they move the point and terminate
immediately.  If there's a pending operator, they move the point and
execute this operator on the resulting region.

A *Text object* is a motion command that move both the point AND
the mark.

Motions can have *scopes*.

** Numeric arguments

Like Emacs, Divine operators

* Extending Divine
:PROPERTIES:
:custom_id: extending-divine
:END:

This chapter describes how you can add create your own operators,
motions, and modes on top of the standard interface.

** Creating operators

A Divine operator is a command that operates on an existing region, if
there's one (usually in one of the =select-*-modes=), or that declares
itself as “pending” until a motion command has created a region.

#+CALL:describe(func='divine-defcommand,var=3)

#+RESULTS:
:  - FUNCTION: *divine-defcommand*
:

To access the prefix argument from within an operator, see
[[#reading-prefix-arg]].

** Creating motions and text objects

** Creating hybrid bindings

** Using the numeric argument
:PROPERTIES:
:custom_id: reading-prefix-arg
:END:

** Creating modes
* Divine as a framework
:PROPERTIES:
:custom_id: framework
:END:

This chapter details the use of Divine as a framework.  By using
Divine this way, you can easily implement totally different sets of
modes and commands.

It is strongly recommended to at least skim through the
[[#fundamental-concepts]] chapter before reading this section.
* Test

# (insert "\n\n" (yas--document-symbol 'divine-define-key 1))

* @@html:<code class='function'>@@divine-define-key@@html:</code>@@ (=mode= =key= =command= /&rest/ =--cl-rest--=)
:PROPERTIES:
:CUSTOM_ID: divine-define-key
:END:
Bind @@html:<code>@@key@@html:</code>@@ to @@html:<code>@@command@@html:</code>@@ in Divine mode @@html:<code>@@mode@@html:</code>@@.

 - @@html:<code>@@mode@@html:</code>@@ is the short name of a Divine mode, like 'normal or 'insert.

 - /state/ is a predicate that depends of the current
   interactive state of Divine.  It usually corresponds to the
   type of the command.

   - :numeric-arg :: Holds if a numeric argument is legal.
   - :motion      :: Holds if amotion is legal.
   - :object      :: Holds if text object is legal.
   - :action      :: Holds if a action is legal.
   - :operator    :: Holds i an operator binding has been repeated (eg =dd=).
   - :operator*   :: Match the special case where an operator is pending and its binding is repeated.
   - :scope       :: Match states where a scope modifier is legal.

 - /emacs-mode/ is a symbol identifying an Emacs major or minor
   mode.  Minor modes take precedence over major modes.

 - /predicate/ determines condition that must hold for the binding
   to be executed.  It thus allows multiple commands to easily
   share the same binding.

/predicate/ is compiled by =divine-compile-predicate=, which see.

(fn @@html:<code>@@mode@@html:</code>@@ @@html:<code>@@key@@html:</code>@@ @@html:<code>@@command@@html:</code>@@ &key ((:mode /emacs-mode/) t) ((:in /state/) nil) ((:when /pred/) nil))

//
